/*******************************************************************************
**  DAVE App Name : SYSTM002       App Version: 1.0.0               
**  This file is generated by DAVE, User modification to this file will be    **
**  overwritten at the next code generation.                                  **
*******************************************************************************/

/*CODE_BLOCK_BEGIN[SYSTM002.h]*/
/******************************************************************************
 * @file     SYSTM002.h
 * @brief    Simple System Timer App implementation header file.
 *
 * @version  V1.0.0
 * @date     25 Sep 2013
 *
 * @note
 * Copyright (C) 2012-2013 Infineon Technologies AG. All rights reserved.

 *
 * @par
 * Infineon Technologies AG (Infineon) is supplying this software for use with
 * Infineon's microcontrollers.
 *
 * This file can be freely distributed within development tools that are
 * supporting such microcontrollers.
 *
 *
 * @par
 * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
 * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
 * INFINEON SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL,
 * OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 ******************************************************************************/
/**************************** Change history ***********************************
 * V1.0.0,	25-Sep-13	 Initial Version

 * *************************** Change history *********************************/


#ifndef SYSTM002_H_
#define SYSTM002_H_
/* Inclusion of header file */
#include <DAVE3.h>

/*******************************************************************************
**                      Global Macro Definitions                              **
*******************************************************************************/

/**
 * @ingroup SYSTM002_publicparam
 * @{
 */

  /* System Core clock frequency in MHz */

  
#define SYSTM002_SYS_CORE_CLOCK  32.0 


  /* Time between between two systick interrupt in Msec */
#define SYSTM002_SYSTICK_INTERVAL 1000U
  /* Maximum No of timer */
#define SYSTM002_CFG_MAX_TMR  16U 

/* Macro function to convert systick count to microsecond */
#define CONVERT_SYSTICK_COUNT_TO_USEC(val) ( (val * SYSTM002_SYSTICK_INTERVAL)/1000U )
/* Macro function to convert microsecond to systick count */
#define CONVERT_USEC_TO_SYSICK_COUNT(val)   (SYSTM002_SYS_CORE_CLOCK * val)

/**
 * @}
 */

/*******************************************************************************
**                      Global Type Definitions                               **
*******************************************************************************/
/**
 * @ingroup SYSTM002_publicparam
 * @{
 */

/*
 * This enumeration define possible timer state.
 */
typedef enum SYSTM002_TimerStateType{
/**
 * The timer is in running state
 */
  SYSTM002_STATE_RUNNING,
/**
  * The timer is stopped
 */
  SYSTM002_STATE_STOPPED
}SYSTM002_TimerStateType;

/**
 * Enum values which describes timer types
 */
typedef enum SYSTM002_TimerType
{
  /**
    * Timer Type is one shot.
    */
  SYSTM002_ONE_SHOT,
  /**
   * Timer Type is periodic.
   */
  SYSTM002_PERIODIC
}SYSTM002_TimerType;



/**
 * Enum values which describes return status of functions
 */
typedef enum SYSTM002_ErrorCodesType
{
  /**
   * Invalid Handle.
   */
  /**
   * @cond INTERNAL_DOCS
   * @param MODULENAME SYSTM002
   * @endcond
  */
  /**
   * @cond INTERNAL_DOCS
   * @param	ERRCODESTRING1 SYSTM002_INVALID_HANDLE_ERROR
   * @param	STRCODESTRING1 Input handle is not valid
   * @endcond
  */
  SYSTM002_INVALID_HANDLE_ERROR = 1,
  /**
   * Timer error occured.
   */
  /**
   * @cond INTERNAL_DOCS
   * @param	ERRCODESTRING2 SYSTM002_ERROR
   * @param	STRCODESTRING2 Timer Error
   * @endcond
  */
  SYSTM002_ERROR,
  /**
   * Debuglog function entry.
   */
  /**
   * @cond INTERNAL_DOCS
   * @param	ERRCODESTRING3 SYSTM002_FUNCTION_ENTRY
   * @param	STRCODESTRING3 Entered function \%s
   * @endcond
   *
   */
  SYSTM002_FUNCTION_ENTRY,
  /**
   * Debuglog function exit.
   */
  /**
   * @cond INTERNAL_DOCS
   * @param ERRCODESTRING4 SYSTM002_FUNCTION_EXIT
   * @param STRCODESTRING4 Exited function \%s
   * @endcond
  */
  SYSTM002_FUNCTION_EXIT
}SYSTM002_ErrorCodesType;


/**
 * Timer callback function pointer.
 */
typedef void (*SYSTM002_TimerCallBackPtr)(void* ParamToCallBack);



/**
 * Global structure which acts as the timer control block .
 *  
 */
typedef struct SYSTM002_TimerObject
{
  /* <<<DD_SYSTM002_STRUCT_1>>> */
  /** Timer ID  */
  uint32_t TimerID;
  /** Timer Type (Single Shot or Periodic)*/
  SYSTM002_TimerType TimerType;
  /** Timer State  */
  SYSTM002_TimerStateType TimerState;
  /** Timer Counter  */
  uint32_t TimerCount;
  /** Timer Reload Counter value */
  uint32_t TimerReload;
  /** Callback function pointer */
  SYSTM002_TimerCallBackPtr TimerCallBack;
  /** Parameter to callback function */
  void* ParamToCallBack;
  /** pointer to next timer control block*/
  struct SYSTM002_TimerObject*  TimerNext;
  /** Pointer to previous timer control block */
  struct SYSTM002_TimerObject*  TimerPrev;
}SYSTM002_TimerObject;


/**
 * @}
 */

/*******************************************************************************
**                      Global Constant Declarations                          **
*******************************************************************************/


/*******************************************************************************
**                      Extern Variables                                      **
*******************************************************************************/


/*******************************************************************************
**                     FUNCTION PROTOTYPES                                    **
*******************************************************************************/
/**
 * @ingroup SYSTM002_apidoc
 * @{
 */


/**
 * Initializes the systick counter as per the systick interval specified by the 
 * user and start the systick counter. It also initializes global variables.
 *
 * @return     void
 *
 *
 * <b>Reentrant: NO </b><BR>
 * <BR><P ALIGN="LEFT"><B>Example:</B>
 * @code
 *  #include <DAVE3.h>
 *  int main(void)
 *  {
 *    // Initialize and Systick counter
 *    DAVE_Init(); // SYSTM002_Init() will be called within DAVE_Init()
 *    // ... infinite loop ...
 *    while(1)
 *    {
 *    
 *    }
 *     
 *  }
 * @endcode<BR> </p>
 */
void  SYSTM002_Init( void);


/**
 *  Creates a new software Timer.
 *  
 *  Note : This App uses SysTick Exception for controlling the timer list. Call back function
 *  registered through this function will be called in SysTick exception when the timer is expired.
 *  One shot timers are removed from the timer list, if it expires. To use
 *  this SW timer again it has to be first deleted and then created again. 
 *  Periodic timer will be added again to the timer list with the same periodic
 *  value after it expires.
 *
 *
 * @param[in]  Period Timer period value in microseconds
 * @param[in]  TimerType Type of Timer(ONE_SHOT/PERIODIC)
 * @param[in]  TimerCallBack Call back function of the timer(No Macros are allowed)
 * @param[in]  pCallBackArgPtr Call back function parameter
 *
 * @return     handle_t<BR> 
 *             Timer ID : If timer created successfully.<BR>
 *             0  : If timer creation failed.<BR>
 *
 *
 * <b>Reentrant: NO </b><BR>
 *
 * <BR><P ALIGN="LEFT"><B>Example:</B>
 * @code
 *  #include <DAVE3.h>
 * static volatile bool TimerExpired;
 * void my_func_a(void* Temp)
 *  {
 *    static uint32_t Count = 1;
 *    if(Count == 10)
 *    {
 *      TimerExpired = TRUE;
 *    }
 *    Count++;
 *  }
 *  int main(void)
 *  {
 *    handle_t TimerId;
 *    // ... Initializes Apps configurations ...
 *    DAVE_Init();
 *    TimerId = SYSTM002_CreateTimer(100,SYSTM002_PERIODIC,my_func_a,NULL);
 *    if(TimerId != 0)
 *    {
 *    //Timer is created successfully
 *    }
 *    // ... infinite loop ...
 *    while(1)
 *    {
 *    
 *    }
 *     
 *  }
 * @endcode<BR> </p>
 */
handle_t SYSTM002_CreateTimer
(
  uint32_t Period,
  SYSTM002_TimerType TimerType,
  SYSTM002_TimerCallBackPtr TimerCallBack,
  void  * pCallBackArgPtr
);

/**
 * Starts the software timer .
 *
 *
 * @param[in]  Handle Timer ID obtained from SYSTM002_CreateTimer
 *
 * @return     status_t<BR>
 *             DAVEApp_SUCCESS 			: If timer is started successufully<BR>
 *             SYSTM002_INVALID_HANDLE  : If Timer ID  passed is invalid<BR>
 *
 * <b>Reentrant: NO </b><BR>
 *
 * <BR><P ALIGN="LEFT"><B>Example:</B>
 * @code
 *  #include <DAVE3.h>
 *  static volatile bool TimerExpired; 
 *  void my_func_a(void* Temp)
 *  {
 *    static uint32_t Count = 1;
 *    if(Count == 10)
 *    {
 *      TimerExpired = TRUE;
 *    }
 *    Count++;
 *  }
 *  int main(void)
 *  {
 *    handle_t TimerId;
 *    uint32_t Status = SYSTM002_ERROR;
 *    // ... Initializes Apps configurations ...
 *    DAVE_Init();
 *    TimerId = SYSTM002_CreateTimer(100,SYSTM002_PERIODIC,my_func_a,NULL);
 *    if(TimerId != 0)
 *    {
 *      //Timer is created successfully
 *   	Status = SYSTM002_StartTimer(TimerId);
 *   	if(Status == DAVEApp_SUCCESS)
 *   	{
 *   	         //Timer started
 *   	}
 *	  }
 *    // ... infinite loop ...
 *    while(1)
 *    {
 *    
 *    }
 *  }
 * @endcode<BR> </p>
 */
status_t SYSTM002_StartTimer(handle_t  Handle) ;


/**
 * Stops the software timer
 *
 * @param[in]  Handle Timer ID obtained from SYSTM002_CreateTimer
 *
 * @return     status_t<BR>
 *             DAVEApp_SUCCESS 			: if timer is stopped successfully.<BR>
 *             SYSTM002_INVALID_HANDLE  : If Timer ID  passed is invalid.<BR>
 *
 * <b>Reentrant: NO </b><BR>
 *
 * <BR><P ALIGN="LEFT"><B>Example:</B>
 * @code
 *  #include <DAVE3.h>
 *  static volatile bool TimerExpired;
 *  void my_func_a(void* Temp)
 *  {
 *   static uint32_t Count = 1;
 *   if(Count == 10)
 *   {
 *     TimerExpired = TRUE;
 *   }
 *    Count++;
 *  }
 *  int main(void)
 *  {
 *    handle_t TimerId;
 *   uint32_t Status = SYSTM002_ERROR;
 *   // ... Initializes Apps configurations ...
 *    DAVE_Init();
 *    TimerId = SYSTM002_CreateTimer(100,SYSTM002_PERIODIC,my_func_a,NULL);
 *    if(TimerId != 0)
 *    {
 *      //Timer is created successfully
 *    	Status = SYSTM002_StartTimer(TimerId);
 *      if(Status == DAVEApp_SUCCESS)
 *    	{
 *    	   // Wait till timer is expired
 *    	   while(TimerExpired == FALSE)
 *         {}
 *    		//stop the timer
 *    		Status = SYSTM002_StopTimer(TimerId);
 *    	    if(Status == DAVEApp_SUCCESS)
 *    		{
 *    	      //Timer stopped
 *    		}
 *       }
 *       // start the timer
 *        SYSTM002_StartTimer(TimerId);
 *    }
 *    // ... infinite loop ...
 *    while(1)
 *    {
 *     
 *    }
 *      
 * }
 * @endcode<BR> </p>
 */
status_t SYSTM002_StopTimer(handle_t Handle) ;

/**
 * Deletes the software timer from the timer list.
 *  
 *  Note : One shot timers are removed from the timer list, if it expires. To use 
 *  this SW timer again it have to be first deleted and then created again. 
 *  Periodic timer will be added again to the timer list with the same periodic
 *  value after it expires.
 *
 *
 * @param[in]  Handle Timer ID
 *
 * @return     status_t<BR>
 *             DAVEApp_SUCCESS 			: if timer is deleted successufully.<BR>
 *             SYSTM002_INVALID_HANDLE  : If Timer ID  passed is invalid.<BR>
 *
 * <b>Reentrant: NO </b><BR>
 *
 * <BR><P ALIGN="LEFT"><B>Example:</B>
 * @code
 *  #include <DAVE3.h>
 *  static volatile bool TimerExpired;
 *  void my_func_a(void* Temp)
 *  {
 *   static uint32_t Count = 1;
 *   if(Count == 10)
 *   {
 *     TimerExpired = TRUE;
 *   }
 *   Count++;
 *  }
 *  int main(void)
 *  {
 *    handle_t TimerId;
 *    uint32_t Status = SYSTM002_ERROR;
 *    // ... Initializes Apps configurations ...
 *    DAVE_Init();
 *    TimerId = SYSTM002_CreateTimer(100,SYSTM002_PERIODIC,my_func_a,NULL);
 *    if(TimerId != 0)
 *    {
 *      //Timer is created successfully
 *      Status = SYSTM002_StartTimer(TimerId);
 *      if(Status == DAVEApp_SUCCESS)
 *    	{
 *        // Wait till timer is expired
 *        while(TimerExpired == FALSE)
 *        {}
 *    	  //stop the timer
 *    	  Status = SYSTM002_StopTimer(TimerId);
 *        if(Status == DAVEApp_SUCCESS)
 *    	  {
 *    	    SYSTM002_DeleteTimer(TimerId);
 *    	  }
 *      }
 *    }    
 *    // ... infinite loop ...
 *    while(1)
 *    {
 *     
 *    } 
 * }
 * @endcode<BR> </p>
 */
status_t SYSTM002_DeleteTimer(handle_t Handle) ;


/**
 * Gives the current system time in microsec since start of counter.
 *
 *
 * @return     uint32_t returns current system time in microsec.
 *
 *
 * <b>Reentrant: NO </b><BR>
 *
 * <BR><P ALIGN="LEFT"><B>Example:</B>
 * @code
 *  #include <DAVE3.h>
 *  static volatile bool TimerExpired; 
 *  void my_func_a(void* Temp)
 *  {
 *    static uint32_t Count = 1;
 * 	  if(Count == 10)
 *    {
 *      TimerExpired = TRUE;
 *    }
 *    Count++;
 *  }
 *  int main(void)
 *  {
 * 	  handle_t TimerId;
 *    uint32_t SystemTime = 0;
 *    uint32_t Status = SYSTM002_ERROR;
 *    // ... Initializes Apps configurations ...
 *    DAVE_Init();
 *    TimerId = SYSTM002_CreateTimer(100,SYSTM002_PERIODIC,my_func_a,NULL);
 *    if(TimerId != 0)
 *    {
 *      //Timer is created successfully
 *      Status = SYSTM002_StartTimer(TimerId);
 *      if(Status == DAVEApp_SUCCESS)
 *      {
 *        SystemTime = SYSTM002_GetTime();
 *      }
 *    }
 *     // ... infinite loop ...
 *    while(1)
 *    {
 *    
 *    }
 * }
 * @endcode<BR> </p>
 */
uint32_t  SYSTM002_GetTime(void);


/**
 * Utility function to get the no of system ticks for the
 * specified period given in microsec.
 *
 *
 * @return     uint32_t returns no of system ticks
 *
 *
 * <b>Reentrant: NO </b><BR>
 *
 * <BR><P ALIGN="LEFT"><B>Example:</B>
 * @code
 *  #include <DAVE3.h>
 *  int main(void)
 *  {
 *    uint32_t SysTickCount = 0;
 *    DAVE_Init();
 *    // Get systick timer count value for 100microsec
 *    SysTickCount = SYSTM002_GetSysTickCount(100);
 *    return 0;
 *  }
 * @endcode<BR> </p>
 */
uint32_t  SYSTM002_GetSysTickCount(uint32_t Period );

/**
 *@}
 */

#endif /* SYSTM002_H_ */   

/*CODE_BLOCK_END*/
